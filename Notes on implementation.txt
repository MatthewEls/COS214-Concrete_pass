For Strategy design pattern, we have different strategies we could implement; if the customer is paying for the bill as a whole, into sub bills or if it goes on the customers tab. The paymentMethod is an attribute of a customer, this means a customer must have a payment method attached to them when created(here this is done in the createCustomer function)
-We also assume one strategy to split the bills, this being we always take in the bill amount divided by the party size(a customer cannot spilt the bill in their own way).
In this design pattern we also make use of the template method design pattern, to be more specific a customer can select a payment method and within the chosen payment strategy it leverages the common calculation steps while customising specific behaviours through the template method. In our system, a specific tab calculation (StandardTabCalculator or HappyHourTabCalculator) will take place depending on certain information of the customer. If the customer has a tab and they made a reservation for between 17:00 and 18:00 their current subtotal is discounted before it is added to the customer outstanding amount(our system assumes that tabs are fully settled outside of it and the customers outstanding amount, even though entered by user will always be accurate). The "total bill" returned will just indicate the customers current tab(outstanding amount)
Participants are as follows:
In strategy:
Context: Customer
Strategy: paymentMethod
Concrete strategies: oneBill, splitBill, Tab

In Template method:
AbstractClass: TabCalculator
ConcereteClass(es): StandardTabCalculator, HappyHourTabCalculator

For when a customer wants to order we use the observer and state design pattern, where the waiter is the observer of the customers state (wether they are ready to order or not). In our implementation the waiter observes the state of a Table to determine whether the customer is ready to order (We use table object to minimise interaction between customer and waiter class)
The table is the subject, it maintains a list of observers, in this case writers, and notifies them, when its state changes(when a customer is ready to order). It also represents the context in the state pattern, it has reference to the current state object and delegates behaviour to the state object. When a customer is ready to order the table switches to the readyState
The Observer class acts as an interface for observers
The Waiter class acts as an observer, it is registered with  tables and receives notifications accordingly. It inherits from the Observer class
The CustomerState class acts as an interface for the customers ready to order state
NotReadyState and ReadyState both are concrete state classes


Assumptions about system: